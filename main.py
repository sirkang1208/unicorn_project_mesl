from __future__ import print_function
from unicorn import *
from capstone import *
from capstone.arm import *
from xprint import to_hex, to_x_32
from unicorn.arm_const import *
import sys
import datetime





ARM_CODE32 = b"\x37\x00\xa0\xe3\x03\x10\x42\xe0\x37\x00\xa0\xe3\x03\x10\x42\xe0\x37\x00\xa0\xe3\x03\x10\x42\xe0\x37\x00\xa0\xe3\x03\x10\x42\xe0"

# memory address where emulation starts
# address must finished in 0
ADDRESS = 0x10000
COUNT = 0

def print_insn_detail(insn):
    # print address, mnemonic and operands
    print("0x%x:\t%s\t%s" % (insn.address, insn.mnemonic, insn.op_str))

    # "data" instruction generated by SKIPDATA option has no detail
    if insn.id == 0:
        return
    
    (regs_read, regs_write) = insn.regs_access()

    if len(regs_read) > 0:
        print("\tRegisters read:", end="")
        for r in regs_read:
            print(" %s" %(insn.reg_name(r)), end="")
        print("")

    if len(regs_write) > 0:
        print("\tRegisters modified:", end="")
        for r in regs_write:
            print(" %s" %(insn.reg_name(r)), end="")
        print("")

def print_all_reg(uc):
    r0 = uc.reg_read(UC_ARM_REG_R0)
    r1 = uc.reg_read(UC_ARM_REG_R1)
    r2 = uc.reg_read(UC_ARM_REG_R2)
    r3 = uc.reg_read(UC_ARM_REG_R3)
    r4 = uc.reg_read(UC_ARM_REG_R4)
    r5 = uc.reg_read(UC_ARM_REG_R5)
    r6 = uc.reg_read(UC_ARM_REG_R6)
    r7 = uc.reg_read(UC_ARM_REG_R7)
    r8 = uc.reg_read(UC_ARM_REG_R8)
    r9 = uc.reg_read(UC_ARM_REG_R9)
    r10 = uc.reg_read(UC_ARM_REG_R10)
    fp = uc.reg_read(UC_ARM_REG_FP)
    ip = uc.reg_read(UC_ARM_REG_IP)
    sp = uc.reg_read(UC_ARM_REG_SP)
    lr = uc.reg_read(UC_ARM_REG_LR)
    pc = uc.reg_read(UC_ARM_REG_PC)
    cpsr = uc.reg_read(UC_ARM_REG_CPSR)
    
    print("R0 = 0x%x" %r0, end = ', ')
    print("R1 = 0x%x" %r1, end = ', ')
    print("R2 = 0x%x" %r2, end = ', ')
    print("R3 = 0x%x" %r3, end = ', ')
    print("R4 = 0x%x" %r4, end = ', ')
    print("R5 = 0x%x" %r5, end = ', ')
    print("R6 = 0x%x" %r6, end = ', ')
    print("R7 = 0x%x" %r7, end = ', ')
    print("R8 = 0x%x" %r8, end = ', ')
    print("R9 = 0x%x" %r9, end = ', ')
    print("R10 = 0x%x" %r10, end = ', ')
    print("FP = 0x%x" %fp, end = ', ')
    print("IP = 0x%x" %ip, end = ', ')
    print("SP = 0x%x" %sp, end = ', ')
    print("LR = 0x%x" %lr, end = ', ')
    print("PC = 0x%x" %pc, end = ', ')
    print("CPSR = 0x%x" %cpsr, end = ' ')
    
def print_mem(uc,a):
    tot_mem = uc.mem_read(a,4)
    print("/ memory data : ", end = "")
    for i in range(len(tot_mem)):
        print("\\x%x" %tot_mem[i], end = "")
    print()

def select_func(uc,a):
    if a == 'r':
        change_reg(uc)
    elif a == 'm':
        change_mem(uc)
    elif a == 'rv':
        print_all_reg(uc)
    elif a == 'mv':
        print_mem(uc)
    elif a == 'p':
        pass

def change_mem(uc,a):
    addr = input("input address : ")

def change_reg(uc):
    r_num = input('register number : ')
    REG = {'0' : UC_ARM_REG_R0, '1' : UC_ARM_REG_R1, '2' : UC_ARM_REG_R2, '3' : UC_ARM_REG_R3,
            '4' : UC_ARM_REG_R4, '5' : UC_ARM_REG_R5, '6' : UC_ARM_REG_R6, '7' : UC_ARM_REG_R7,
            '8' : UC_ARM_REG_R8, '9' : UC_ARM_REG_R9, '10' : UC_ARM_REG_R10, "fp" : UC_ARM_REG_FP,
            "ip" : UC_ARM_REG_IP, "sp" : UC_ARM_REG_SP, "lr" : UC_ARM_REG_LR, "pc": UC_ARM_REG_PC,
            "cpsr" : UC_ARM_REG_CPSR}.get(r_num, "알 수 없는")
    if REG == "알 수 없는":
        print("wrong register number")
        return
    data = input('data : ')
    uc.reg_write(REG,int(data))

# callback for tracing instructions
def hook_code(uc, address, size, user_data):
    filename = datetime.datetime.now().strftime("%Y-%m-%d %H_%M_%S")
    filename = filename + ".txt"
    sys.stdout = open(filename,'a')
    
    global COUNT
    #break every each instruction and get input
    print("instruction :", user_data[COUNT][0],end=' ')
    # print(clock(user_data[count][0]))
    print("/ register data :", end="")
    print_all_reg(uc)
    print("/ modified register : ", end ='')
    print(user_data[COUNT][1:], end = ' ')
    print_mem(uc,address)
    COUNT += 1
    # do single step debugging here


def main():

    print("Emulate ARM code")

    try:
        mu = Uc(UC_ARCH_ARM, UC_MODE_ARM)
        # Initialize emulator in ARM mode
        mc = Cs(CS_ARCH_ARM, CS_MODE_ARM)
        # map 2MB memory for this emulation
        mu.mem_map(ADDRESS,2*1024*1024)


        # write machine code to be emulated to memory
        mu.mem_write(ADDRESS, ARM_CODE32)

        # initialize machine registers
        mu.reg_write(UC_ARM_REG_R0, 0x1234)
        mu.reg_write(UC_ARM_REG_R2, 0x6789)
        mu.reg_write(UC_ARM_REG_R3, 0x3333)
        mu.reg_write(UC_ARM_REG_APSR, 0xFFFFFFFF) #All application flags turned on
        
        i = 0
        copy_mne = []
        print("*" * 16)
        print("Platform: ARM")
        print("Code: %s" % to_hex(ARM_CODE32))
        print("Disasm:")

        mc.syntax = None
        mc.detail = True
        for insn in mc.disasm(ARM_CODE32, 0x10000):
            line = []
            copy_mne.append(line)
            copy_mne[i].append(insn.mnemonic)
            (regiread,regiwrite) = insn.regs_access()
            for r in regiwrite:
                copy_mne[i].append(insn.reg_name(r))
            print_insn_detail(insn)
            print ()
            i += 1
        
        print(copy_mne)

        # tracing one instruction at ADDRESS with customized callback
        mu.hook_add(UC_HOOK_CODE, hook_code,copy_mne, begin=ADDRESS, end=ADDRESS+len(ARM_CODE32))

        # emulate machine code in infinite time
        mu.emu_start(ADDRESS, ADDRESS + len(ARM_CODE32))

        # now print out some registers
        print(">>> Emulation done. Below is the CPU context")

        #print(debug())

    except UcError as e:
        print("ERROR: %s" % e)


if __name__ == "__main__":
    main()